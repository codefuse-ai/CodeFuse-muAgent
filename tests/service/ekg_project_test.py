# -*- coding: utf-8 -*-
from loguru import logger
import os, sys
import json

src_dir = os.path.join(
    os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
)
sys.path.append(src_dir)
try:
    import test_config
except Exception as e:
    # set your config
    logger.error(f"{e}")


src_dir = os.path.join(
    os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
)
sys.path.append(src_dir)

import logging
# Set the logging level to WARNING, which will suppress INFO and DEBUG messages
logging.basicConfig(level=logging.ERROR)


from muagent import EKG, get_ekg_project_config_from_env
# nodes = [{'id': 'haPvrjEkz4LARZyR7OAuPmVMHMIQPMew',
#   'type': 'opsgptkg_intent',
#   'attributes': {'description': '需要公司多人参与的事务，以及相关的问题', 'name': '公司事务'}},
#  {'id': 'dicVRAk5rT3y9LxcmBCN2jDi1TjHc5rm',
#   'type': 'opsgptkg_intent',
#   'attributes': {'description': '与个人有关的事务(如个人贷款），或遇到的个人问题，不涉及公司事务',
#    'name': '个人事务'}},
#  {'id': 'ClKvwjBRZUJC7ttSZaiT0dh7lhSujNWi',
#   'type': 'opsgptkg_intent',
#   'attributes': {'description': '公司活动', 'name': '公司活动'}},
#  {'id': 'NyBXAHQckQx1xL5lnSgBGlotbZkkQ9C7',
#   'type': 'opsgptkg_intent',
#   'attributes': {'description': '金融（如借款、存款、贷款等）', 'name': '金融'}},
#  {'id': '6sa4zJCnVKJxKMtOtypapjZk4sdo93QU',
#   'type': 'opsgptkg_intent',
#   'attributes': {'description': '医疗(包括预约、挂号、看病、诊断等)', 'name': '医疗'}},
#  {'id': 'a8d85669_141a_4f54_ab8c_209c08d27c35',
#   'type': 'opsgptkg_schedule',
#   'attributes': {'description': '组织一次公司活动',
#    'name': '组织一次公司活动',
#    'enable': 'False'}},
#  {'id': '2b8df337_f29e_4d49_865f_84088c3a94e7',
#   'type': 'opsgptkg_schedule',
#   'attributes': {'description': '在线申请贷款',
#    'name': '在线申请贷款',
#    'enable': 'False'}},
#  {'id': 'b9fe38f1_33f6_468b_a1dd_43efdfd8e2d1',
#   'type': 'opsgptkg_schedule',
#   'attributes': {'description': '预约医生', 'name': '预约医生', 'enable': 'False'}},
#  {'id': '98234102_4e4a_4997_9b1e_3cda6382b1c7',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '确定活动主题：确定活动的主要目的（如团建、庆祝活动等）',
#    'name': '确定活动主题：确定活动的主要目的（如团建、庆祝活动等）'}},
#  {'id': '59030678_760d_4a10_8d61_0d4e4cc5fbcb',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '访问贷款平台：输入网址并访问贷款申请网站',
#    'name': '访问贷款平台：输入网址并访问贷款申请网站'}},
#  {'id': '5afab73b_8f03_422f_856e_386f183bdd71',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '选择医院/医生：访问医院官网或APP，查找相关科室和医生',
#    'name': '选择医院/医生：访问医院官网或APP，查找相关科室和医生'}},
#  {'id': '95ec00ef_cc9c_4947_a21c_88eeb9a71af5',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '选择活动类型', 'name': '选择活动类型'}},
#  {'id': '5504af87_416e_4ee5_bfce_86b969a63433',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '注册/登录：如果你已经注册,输入用户名和密码进行登录。如果你还没有注册,点击“注册”按钮，填写个人信息，创建账户',
#    'name': '注册/登录：如果你已经注册,输入用户名和密码进行登录。如果你还没有注册,点击“注册”按钮，填写个人信息，创建账户'}},
#  {'id': '3ff8f54a_fa65_4368_86ce_d65058035dd0',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '查看可预约时间：点击医生姓名，查看可预约时段',
#    'name': '查看可预约时间：点击医生姓名，查看可预约时段'}},
#  {'id': 'd5e760b4_ae82_410d_a73d_4c0c98926ae5',
#   'type': 'opsgptkg_phenomenon',
#   'attributes': {'description': '室内活动', 'name': '室内活动'}},
#  {'id': '2a37b90a_fd96_4548_989c_7c1e8fa9d881',
#   'type': 'opsgptkg_phenomenon',
#   'attributes': {'description': '户外活动', 'name': '户外活动'}},
#  {'id': '88d4cf2b_7cf5_4e40_b54e_59268f119f63',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '选择贷款类型：浏览可用的贷款类型（如个人贷款、汽车贷款、房屋贷款），选择适合自己的贷款类型',
#    'name': '选择贷款类型：浏览可用的贷款类型（如个人贷款、汽车贷款、房屋贷款），选择适合自己的贷款类型'}},
#  {'id': '39021995_6e63_4907_9d67_26ba50d0cd44',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '填写个人信息：输入姓名、联系方式等，选择预约时间',
#    'name': '填写个人信息：输入姓名、联系方式等，选择预约时间'}},
#  {'id': '59fe9c1d_0731_403e_936a_2e2bbba4b3ee',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '选择具体的室内活动（如会议、晚会、游戏），确定场地和时间，准备相关的设备（如投影仪、音响），安排餐饮和娱乐节目，发出邀请通知',
#    'name': '选择具体的室内活动（如会议、晚会、游戏），确定场地和时间，准备相关的设备（如投影仪、音响），安排餐饮和娱乐节目，发出邀请通知'}},
#  {'id': '60163dc6_87af_4972_b350_6b9275975c83',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '选择具体的户外活动（如远足、烧烤、运动会），确定地点和时间，安排交通工具和安全措施，联系供应商（如餐饮、设备租赁），发出邀请通知',
#    'name': '选择具体的户外活动（如远足、烧烤、运动会），确定地点和时间，安排交通工具和安全措施，联系供应商（如餐饮、设备租赁），发出邀请通知'}},
#  {'id': '910f3634_b999_4cf3_94c9_346a67b0d5ed',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '填写申请表：提供个人信息（如姓名、年龄、收入等），提供贷款金额和贷款目的',
#    'name': '填写申请表：提供个人信息（如姓名、年龄、收入等），提供贷款金额和贷款目的'}},
#  {'id': '1330ad69_dfc3_4538_864e_6867a3fd8dd4',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '确认预约：检查预约信息，点击“确认预约”按钮',
#    'name': '确认预约：检查预约信息，点击“确认预约”按钮'}},
#  {'id': 'fcbc3e04_ad8c_4aad_9f75_191f8037ced8',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '预算审核：计算活动预估费用，提交预算给管理层审核',
#    'name': '预算审核：计算活动预估费用，提交预算给管理层审核'}},
#  {'id': '2c7a0d7b_a490_41b9_a6f8_e71b5212e0be',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '提交资料：上传所需文件（如身份证、收入证明等）',
#    'name': '提交资料：上传所需文件（如身份证、收入证明等）'}},
#  {'id': '3cd46fb7_e11c_4181_8670_2f080a453142',
#   'type': 'opsgptkg_phenomenon',
#   'attributes': {'description': '接收通知：收到预约确认短信或邮件',
#    'name': '接收通知：收到预约确认短信或邮件'}},
#  {'id': '0f4610cd_cf6a_475b_8ac0_80166569a292',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '审核资料：系统开始审核申请', 'name': '审核资料：系统开始审核申请'}},
#  {'id': 'b9f81925_b43a_459d_9902_1bc4b024f5a1',
#   'type': 'opsgptkg_phenomenon',
#   'attributes': {'description': '审核通过', 'name': '审核通过'}},
#  {'id': '191687cd_1b76_4e77_9f2a_e67936dd372e',
#   'type': 'opsgptkg_phenomenon',
#   'attributes': {'description': '审核失败', 'name': '审核失败'}},
#  {'id': '18c33ec1_08ef_4df8_b938_7244852d19c8',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '用户收到“申请通过”的通知，前往下一步选择贷款期限和还款方式',
#    'name': '用户收到“申请通过”的通知，前往下一步选择贷款期限和还款方式'}},
#  {'id': 'b73c2551_0890_40fb_b0ca_04912bc21b65',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '提供反馈，建议修改后重新申请', 'name': '提供反馈，建议修改后重新申请'}},
#  {'id': 'e95adaa2_d177_435b_bac7_a8b6047ecc3d',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '确认贷款条件：查看贷款条款和条件',
#    'name': '确认贷款条件：查看贷款条款和条件'}},
#  {'id': '0c561d68_ee31_49d2_82c1_1dac81e731ff',
#   'type': 'opsgptkg_phenomenon',
#   'attributes': {'description': '拒绝条款', 'name': '拒绝条款'}},
#  {'id': '81f579ac_851d_4b85_8608_d2732a2612ff',
#   'type': 'opsgptkg_phenomenon',
#   'attributes': {'description': '接受条款', 'name': '接受条款'}},
#  {'id': '1f0b64aa_5d45_4cf5_bcdd_084b8c125889',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '选择“拒绝”并退出申请流程', 'name': '选择“拒绝”并退出申请流程'}},
#  {'id': '5fd5901a_8adc_4b76_aea2_dcf18884ea0e',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '点击“接受”并继续', 'name': '点击“接受”并继续'}},
#  {'id': '8c999c60_baa7_4e74_903b_f10f148dd12f',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '签署合同：在线签署贷款合同', 'name': '签署合同：在线签署贷款合同'}},
#  {'id': 'e1004c60_5c0c_4f32_b765_a57cc4d39dcc',
#   'type': 'opsgptkg_analysis',
#   'attributes': {'summaryswitch': 'False',
#    'description': '根据提示前往医院就诊',
#    'name': '根据提示前往医院就诊'}},
#  {'id': 'c50ff5e3_aa01_4a6c_96d7_d8645303846d',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '活动宣传：制作宣传材料（如海报、邮件通知），在公司内部推广活动信息',
#    'name': '活动宣传：制作宣传材料（如海报、邮件通知），在公司内部推广活动信息'}},
#  {'id': '4f540a57_f73d_451e_aafb_43f1335a18a7',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '活动实施：根据选择的活动类型，执行相关安排，进行现场协调（无论是户外还是室内）',
#    'name': '活动实施：根据选择的活动类型，执行相关安排，进行现场协调（无论是户外还是室内）'}},
#  {'id': 'c9952fa7_7f82_4737_8cfd_bdbb2dabb20e',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '活动反馈：收集参与者的反馈意见，总结活动的成功之处和改进建议',
#    'name': '活动反馈：收集参与者的反馈意见，总结活动的成功之处和改进建议'}},
#  {'id': 'ekg_team_default',
#   'type': 'opsgptkg_intent',
#   'attributes': {'description': '团队起始节点', 'name': '开始'}}]

# nodes = [{'id': '剧本杀/谁是卧底',
#   'type': 'opsgptkg_intent',
#   'attributes': {'description': '谁是卧底', 'name': '谁是卧底', 'extra': ''}},
#  {'id': '剧本杀/狼人杀',
#   'type': 'opsgptkg_intent',
#   'attributes': {'description': '狼人杀', 'name': '狼人杀', 'extra': ''}},
#  {'id': '剧本杀/谁是卧底/智能交互',
#   'type': 'opsgptkg_schedule',
#   'attributes': {'extra': '',
#    'description': '智能交互',
#    'name': '智能交互',
#    'enable': True}},
#  {'id': '剧本杀/狼人杀/智能交互',
#   'type': 'opsgptkg_schedule',
#   'attributes': {'extra': '',
#    'description': '智能交互',
#    'name': '智能交互',
#    'enable': False}},
#  {'id': '剧本杀/谁是卧底/智能交互/分配座位',
#   'type': 'opsgptkg_task',
#   'attributes': {'extra': '{"dodisplay":"True"}',
#    'executetype': '',
#    'description': '分配座位',
#    'name': '分配座位',
#    'accesscriteria': ''}},
#  {'id': '剧本杀/狼人杀/智能交互/位置选择',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '位置选择',
#    'name': '位置选择',
#    'accesscriteria': '',
#    'extra': '{"memory_tag": "all"}',
#    'executetype': ''}},
#  {'id': '剧本杀/谁是卧底/智能交互/角色分配和单词分配',
#   'type': 'opsgptkg_task',
#   'attributes': {'accesscriteria': '',
#    'extra': '{"memory_tag": "None","dodisplay":"True"}',
#    'executetype': '',
#    'description': '角色分配和单词分配',
#    'name': '角色分配和单词分配'}},
#  {'id': '剧本杀/狼人杀/智能交互/角色选择',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '角色选择',
#    'name': '角色选择',
#    'accesscriteria': '',
#    'extra': '{"memory_tag": "None"}',
#    'executetype': ''}},
#  {'id': '剧本杀/谁是卧底/智能交互/通知身份',
#   'type': 'opsgptkg_task',
#   'attributes': {'extra': '{"pattern": "react","dodisplay":"True"}',
#    'executetype': '',
#    'description': '##角色##\n你正在参与“谁是卧底”这个游戏，你的角色是[主持人]。你熟悉“谁是卧底”游戏的完整流程，你需要完成[任务]，保证游戏的顺利进行。\n目前已经完成 1)位置分配; 2)角色分配和单词分配。\n##任务##\n向所有玩家通知信息他们的 座位信息和单词信息。\n发送格式是： 【身份通知】你是{player_name}, 你的位置是{位置号}号， 你分配的单词是{单词}\n##详细步骤##\nstep1.依次向所有玩家通知信息他们的 座位信息和单词信息。发送格式是： 你是{player_name}, 你的位置是{位置号}号， 你分配的单词是{单词}\nstpe2.所有玩家信息都发送后，结束\n\n##注意##\n1. 每条信息只能发送给对应的玩家，其他人无法看到。\n2. 不要告诉玩家的角色信息，即不要高斯他是平民还是卧底角色\n3. 在将每个人的信息通知到后，本阶段任务结束\n##输出##\n请以列表的形式，给出参与者的所有行动。每个行动表示为JSON，格式为\n[{"action": {"player_name":str, "agent_name":str}, "observation" or "Dungeon_Master": [{"memory_tag":str,"content":str}]}, ...]\n\n关键词含义如下：\n_ player_name (str): 行动方的 player_name，若行动方为主持人，为空，否则为玩家的 player_name；\n_ agent_name (str): 行动方的 agent_name，若为主持人，则 agent_name 为 "主持人"，否则为玩家的 agent_name。\n_ content (str): 行动方的具体行为，若为主持人，content 为告知信息；否则，content 为玩家的具体行动。\n_ memory_tag (List[str]): 无论行动方是主持人还是玩家，memory_tag 固定为**所有**信息可见对象的agent_name, 如果信息可见对象为所有玩家，固定为 ["all"]\n\n#example#\n如果是玩家发言，则用 {"action": {"agent_name": "agent_name_c", "player_name":"player_name_d"}, "observation": [{ "memory_tag":["agent_name_a","agent_name_b"],"content": "str"}]} 格式表示。content是玩家发出的信息；memory_tag是这条信息可见的对象，需要填写agent名。不要填写 agent_description\n\n如果agent_name是主持人，则无需输入player_name， 且observation变为 Dungeon_Master。即{"action": {"agent_name": "主持人", "player_name":""}, "Dungeon_Master": [{ "memory_tag":["agent_name_a","agent_name_b"], "content": "str",}]}\n\n##注意事项##\n1. 所有玩家的座位、身份、agent_name、存活状态等信息在开头部分已给出。\n2. "observation" or "Dungeon_Master"如何选择？若 agent_name 为"主持人"，则为"Dungeon_Master"，否则为 "observation"。\n3. 输出列表的最后一个元素一定是{"action": "taskend"}。\n4. 整个list是一个jsonstr，请输出jsonstr，不用输出markdown格式\n5. 结合已有的步骤，每次只输出下一个步骤，即一个 {"action": {"player_name":str, "agent_name":str}, "observation" or "Dungeon_Master": [{"memory_tag":str,"content":str}]}',
#    'name': '通知身份',
#    'accesscriteria': ''}},
#  {'id': '剧本杀/狼人杀/智能交互/向玩家通知消息',
#   'type': 'opsgptkg_task',
#   'attributes': {'extra': '{"pattern": "react"}',
#    'executetype': '',
#    'description': '##角色##\n你正在参与狼人杀这个游戏，你的角色是[主持人]。你熟悉狼人杀游戏的完整流程，你需要完成[任务]，保证狼人杀游戏的顺利进行。\n目前已经完成位置分配和角色分配。\n##任务##\n向所有玩家通知信息他们的座位信息和角色信息。\n发送格式是： 你是{player_name}, 你的位置是{位置号}号，你的身份是{角色名}\n##注意##\n1. 每条信息只能发送给对应的玩家，其他人无法看到。\n##输出##\n请以列表的形式，给出参与者的所有行动。每个行动表示为Python可解析的JSON，格式为\n\n[{"action": {player_name, agent_name}, "observation" or "Dungeon_Master": [{content, memory_tag}, ...]}]\n\n关键词含义如下：\n_ player_name (str): 行动方的 player_name，若行动方为主持人，为空，否则为玩家的 player_name；\n_ agent_name (str): 行动方的 agent_name，若为主持人，则 agent_name 为 "主持人"，否则为玩家的 agent_name。\n_ content (str): 行动方的具体行为，若为主持人，content 为告知信息；否则，content 为玩家的具体行动。\n_ memory_tag (List[str]): 无论行动方是主持人还是玩家，memory_tag 固定为**所有**信息可见对象的agent_name, 如果信息可见对象为所有玩家，固定为 ["all"]\n\n##example##\n如果是玩家发言，则用 {"action": {"agent_name": "agent_name_c", "player_name":"player_name_d"}, "observation": [{"content": "str", "memory_tag":["agent_name_a","agent_name_b"]}]} 格式表示。content是玩家发出的信息；memory_tag是这条信息可见的对象，需要填写agent名。不要填写 agent_description\n\n如果agent_name是主持人，则无需输入player_name， 且observation变为 Dungeon_Master。即{"action": {"agent_name": "主持人", "player_name":""}, "Dungeon_Master": [{"content": "str", memory_tag:["agent_name_a","agent_name_b"]}]}\n\n##注意事项##\n1. 所有玩家的座位、身份、agent_name、存活状态等信息在开头部分已给出。\n2. "observation" or "Dungeon_Master"如何选择？若 agent_name 为"主持人"，则为"Dungeon_Master"，否则为 "observation"。\n3. 输出列表的最后一个元素一定是{"action": "taskend"}。\n4. 整个list是一个jsonstr，请直接输出jsonstr，不用输出markdown格式\n\n##结果##',
#    'name': '向玩家通知消息',
#    'accesscriteria': ''}},
#  {'id': '剧本杀/谁是卧底/智能交互/关键信息_1',
#   'type': 'opsgptkg_task',
#   'attributes': {'executetype': '',
#    'description': '关键信息',
#    'name': '关键信息',
#    'accesscriteria': '',
#    'extra': '{"ignorememory":"True","dodisplay":"True"}'}},
#  {'id': '剧本杀/狼人杀/智能交互/狼人时刻',
#   'type': 'opsgptkg_task',
#   'attributes': {'accesscriteria': 'OR',
#    'extra': '{"pattern": "react"}',
#    'executetype': '',
#    'description': '##背景##\n在狼人杀游戏中，主持人通知当前存活的狼人玩家指认一位击杀对象，所有狼人玩家给出击杀目标，主持人确定最终结果。\n\n##任务##\n整个流程分为6个步骤：\n1. 存活狼人通知：主持人向所有的狼人玩家广播，告知他们当前存活的狼人玩家有哪些。\n2. 第一轮讨论：主持人告知所有存活的狼人玩家投票，从当前存活的非狼人玩家中，挑选一个想要击杀的玩家。\n3. 第一轮投票：按照座位顺序，每一位存活的狼人为自己想要击杀的玩家投票。\n4. 第一轮结果反馈：主持人统计所有狼人的票数分布，确定他们是否达成一致。若达成一致，告知所有狼人最终被击杀的玩家的player_name，流程结束；否则，告知他们票数的分布情况，并让所有狼人重新投票指定击杀目标，主持人需要提醒他们，若该轮还不能达成一致，则取票数最大的目标为最终击杀对象。\n5. 第二轮投票：按照座位顺序，每一位存活的狼人为自己想要击杀的玩家投票。\n6. 第二轮结果反馈：主持人统计第二轮投票中所有狼人的票数分布，取票数最大的玩家为最终击杀对象，如果存在至少两个对象的票数最大且相同，取座位号最大的作为最终击杀对象。主持人告知所有狼人玩家最终被击杀的玩家的player_name。\n\n该任务的参与者只有狼人玩家和主持人，信息可见对象是所有狼人玩家。\n\n##输出##\n请以列表的形式，给出参与者的所有行动。每个行动表示为Python可解析的JSON，格式为\n\n[{"action": {player_name, agent_name}, "observation" or "Dungeon_Master": [{content, memory_tag}, ...]}]\n\n关键词含义如下：\n_ player_name (str): 行动方的 player_name，若行动方为主持人，为空，否则为玩家的 player_name；\n_ agent_name (str): 行动方的 agent_name，若为主持人，则 agent_name 为 "主持人"，否则为玩家的 agent_name。\n_ content (str): 行动方的具体行为，若为主持人，content 为告知信息；否则，content 为玩家的具体行动。\n_ memory_tag (List[str]): 无论行动方是主持人还是玩家，memory_tag 固定为**所有**信息可见对象的agent_name, 如果信息可见对象为所有玩家，固定为 ["all"]\n\n##example##\n如果是玩家发言，则用 {"action": {"agent_name": "agent_name_c", "player_name":"player_name_d"}, "observation": [{"content": "str", "memory_tag":["agent_name_a","agent_name_b"]}]} 格式表示。content是玩家发出的信息；memory_tag是这条信息可见的对象，需要填写agent名。不要填写 agent_description\n\n如果agent_name是主持人，则无需输入player_name， 且observation变为 Dungeon_Master。即{"action": {"agent_name": "主持人", "player_name":""}, "Dungeon_Master": [{"content": "str", memory_tag:["agent_name_a","agent_name_b"]}]}\n\n##注意事项##\n1. 所有玩家的座位、身份、agent_name、存活状态等信息在开头部分已给出。\n2. "observation" or "Dungeon_Master"如何选择？若 agent_name 为"主持人"，则为"Dungeon_Master"，否则为 "observation"。\n3. 输出列表的最后一个元素一定是{"action": "taskend"}。\n4. 整个list是一个jsonstr，请直接输出jsonstr，不用输出markdown格式\n\n##结果##',
#    'name': '狼人时刻'}},
#  {'id': '剧本杀/谁是卧底/智能交互/开始新一轮的讨论',
#   'type': 'opsgptkg_task',
#   'attributes': {'accesscriteria': 'OR',
#    'extra': '{"pattern": "react", "endcheck": "True",\n"memory_tag":"all",\n"dodisplay":"True"}',
#    'executetype': '',
#    'description': '###以上为本局游戏记录###\n\n\n##背景##\n你正在参与“谁是卧底”这个游戏，你的角色是[主持人]。你熟悉“谁是卧底”游戏的完整流程，你需要完成[任务]，保证游戏的顺利进行。\n\n##任务##\n以结构化的语句来模拟进行 谁是卧底的讨论环节。 在这一个环节里，所有主持人先宣布目前存活的玩家，然后每位玩家按照座位顺序发言\n\n\n##详细步骤##\nstep1. 主持人根据本局游戏历史记录，感知最开始所有的玩家 以及 在前面轮数中已经被票选死亡的玩家。注意死亡的玩家不能参与本轮游戏。得到当前存活的玩家个数以及其player_name。 并告知所有玩家当前存活的玩家个数以及其player_name。\nstep2. 主持人确定发言规则并告知所有玩家，发言规则步骤如下: 存活的玩家按照座位顺序由小到大进行发言\n（一个例子：假设总共有5个玩家，如果3号位置处玩家死亡，则发言顺序为：1_>2_>4_>5）\nstep3.  存活的的玩家按照顺序依次发言\nstpe4.  在每一位存活的玩家都发言后，结束\n\n                                      \n                                      \n##注意##\n1.之前的游戏轮数可能已经投票选中了某位/某些玩家，被票选中的玩家会立即死亡，不再视为存活玩家,死亡的玩家不能参与本轮游戏     \n2.你要让所有存活玩家都参与发言，不能遗漏任何存活玩家。在本轮所有玩家只发言一次\n3.该任务的参与者为主持人和所有存活的玩家，信息可见对象为所有玩家。\n4.不仅要模拟主持人的发言，还需要模拟玩家的发言\n5.每一位存活的玩家均发完言后，本阶段结束\n\n\n\n##输出##\n请以列表的形式，给出参与者的所有行动。每个行动表示为JSON，格式为\n[ {"thought": str, "action": {"player_name":str, "agent_name":str}, "observation" or "Dungeon_Master": [{"memory_tag":str,"content":str}] }, ...]\n\n\n\n\n关键词含义如下：\n_ thought (str): 主持人执行行动的一些思考,包括分析玩家的存活状态，对历史对话信息的理解，对当前任务情况的判断等。 \n_ player_name (str): 行动方的 player_name，若行动方为主持人，为空 ;否则为玩家的 player_name；\n_ agent_name (str): 行动方的 agent_name，若为主持人，则 agent_name 为 "主持人"，否则为玩家的 agent_name。\n_ content (str): 行动方的具体行为，若为主持人，content 为告知信息；否则，content 为玩家的具体行动。\n_ memory_tag (List[str]): 无论行动方是主持人还是玩家，memory_tag 固定为本条信息的可见对象的agent_name, 如果信息可见对象为所有玩家，固定为 ["all"]\n\n##example##\n如果是玩家发言，则用 {"thought": "str", "action": {"agent_name": "agent_name_c", "player_name":"player_name_d"}, "observation": [{ "memory_tag":["agent_name_a","agent_name_b"],"content": "str"}]} 格式表示。content是玩家发出的信息；memory_tag是这条信息可见的对象，需要填写agent名。不要填写 agent_description\n\n如果agent_name是主持人，则无需输入player_name， 且observation变为 Dungeon_Master。即{"thought": "str", "action": {"agent_name": "主持人", "player_name":""}, "Dungeon_Master": [{ "memory_tag":["agent_name_a","agent_name_b"], "content": "str",}]}\n\n##注意事项##\n1. 所有玩家的座位、身份、agent_name、存活状态等信息在开头部分已给出。\n2. "observation" or "Dungeon_Master"如何选择？若 agent_name 为"主持人"，则为"Dungeon_Master"，否则为 "observation"。\n3. 输出列表的最后一个元素一定是{"action": "taskend"}。\n4. 整个list是一个jsonstr，请输出jsonstr，不用输出markdown格式\n5. 结合已有的步骤，每次只输出下一个步骤，即一个 {"thought":  str, "action": {"player_name":str, "agent_name":str}, "observation" or "Dungeon_Master": [{"memory_tag":str,"content":str}]}\n6. 如果是人类玩家发言， 一定要选择类似 agent_人类玩家 这样的agent_name',
#    'name': '开始新一轮的讨论'}},
#  {'id': '剧本杀/狼人杀/智能交互/天亮讨论',
#   'type': 'opsgptkg_task',
#   'attributes': {'executetype': '',
#    'description': '##角色##\n你正在参与狼人杀这个游戏，你的角色是[主持人]。你熟悉狼人杀游戏的完整流程，你需要完成[任务]，保证狼人杀游戏的顺利进行。\n##任务##\n你的任务如下: \n1. 告诉玩家昨晚发生的情况: 首先告诉玩家天亮了，然后你需要根据过往信息，告诉所有玩家，昨晚是否有玩家死亡。如果有，则向所有人宣布死亡玩家的名字，你只能宣布死亡玩家是谁如："昨晚xx玩家死了"，不要透露任何其他信息。如果没有，则宣布昨晚是平安夜。\n2. 确定发言规则并告诉所有玩家:\n确定发言规则步骤如下: \n第一步：确定第一个发言玩家，第一个发言的玩家为死者的座位号加1位置处的玩家(注意：最后一个位置+1的位置号为1号座位），如无人死亡，则从1号玩家开始。\n第二步：告诉所有玩家从第一个发言玩家开始发言，除了死亡玩家，每个人都需要按座位号依次讨论，只讨论一轮，所有人发言完毕后结束。注意不能遗忘指挥任何存活玩家发言！\n以下是一个例子：\n```\n总共有5个玩家，如果3号位置处玩家死亡，则第一个发言玩家为4号位置处玩家，因此从他开始发言，发言顺序为：4_>5_>1_>2\n```\n3. 依次指定存活玩家依次发言\n4. 被指定的玩家依次发言\n##注意##\n1. 你必须根据规则确定第一个发言玩家是谁，然后根据第一个发言玩家的座位号，确定所有人的发言顺序并将具体发言顺序并告知所有玩家，不要做任何多余解释\n2. 你要让所有存活玩家都参与发言，不能遗漏任何存活玩家\n##输出##\n请以列表的形式，给出参与者的所有行动。每个行动表示为Python可解析的JSON，格式为\n\n[{"action": {player_name, agent_name}, "observation" or "Dungeon_Master": [{content, memory_tag}, ...]}]\n\n关键词含义如下：\n_ player_name (str): 行动方的 player_name，若行动方为主持人，为空，否则为玩家的 player_name；\n_ agent_name (str): 行动方的 agent_name，若为主持人，则 agent_name 为 "主持人"，否则为玩家的 agent_name。\n_ content (str): 行动方的具体行为，若为主持人，content 为告知信息；否则，content 为玩家的具体行动。\n_ memory_tag (List[str]): 无论行动方是主持人还是玩家，memory_tag 固定为**所有**信息可见对象的agent_name, 如果信息可见对象为所有玩家，固定为 ["all"]\n\n##example##\n如果是玩家发言，则用 {"action": {"agent_name": "agent_name_c", "player_name":"player_name_d"}, "observation": [{"content": "str", "memory_tag":["agent_name_a","agent_name_b"]}]} 格式表示。content是玩家发出的信息；memory_tag是这条信息可见的对象，需要填写agent名。不要填写 agent_description\n\n如果agent_name是主持人，则无需输入player_name， 且observation变为 Dungeon_Master。即{"action": {"agent_name": "主持人", "player_name":""}, "Dungeon_Master": [{"content": "str", memory_tag:["agent_name_a","agent_name_b"]}]}\n\n##注意事项##\n1. 所有玩家的座位、身份、agent_name、存活状态等信息在开头部分已给出。\n2. "observation" or "Dungeon_Master"如何选择？若 agent_name 为"主持人"，则为"Dungeon_Master"，否则为 "observation"。\n3. 输出列表的最后一个元素一定是{"action": "taskend"}。\n4. 整个list是一个jsonstr，请直接输出jsonstr，不用输出markdown格式\n\n##结果（请直接在后面输出，如果后面已经有部分结果，请续写。一定要保持续写后的内容结合前者能构成一个合法的 jsonstr）##',
#    'name': '天亮讨论',
#    'accesscriteria': '',
#    'extra': '{"pattern": "react"}'}},
#  {'id': '剧本杀/谁是卧底/智能交互/关键信息_2',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '关键信息',
#    'name': '关键信息',
#    'accesscriteria': '',
#    'extra': '{"ignorememory":"True","dodisplay":"True"}',
#    'executetype': ''}},
#  {'id': '剧本杀/狼人杀/智能交互/票选凶手',
#   'type': 'opsgptkg_task',
#   'attributes': {'accesscriteria': '',
#    'extra': '{"pattern": "react"}',
#    'executetype': '',
#    'description': '##角色##\n你正在参与“谁是卧底”这个游戏，你的角色是[主持人]。你熟悉“谁是卧底”游戏的完整流程，你需要完成[任务]，保证游戏的顺利进行。\n\n##任务##\n你的任务如下:\n1. 告诉玩家投票规则，规则步骤如下: \nstep1: 确定讨论阶段第一个发言的玩家A\nstep2: 从A玩家开始，按座位号依次投票，每个玩家只能对一个玩家进行投票，投票这个玩家表示认为该玩家是“卧底”。每个玩家只能投一次票。\nstep3: 将完整投票规则告诉所有玩家\n2. 指挥存活玩家依次投票。\n3. 被指定的玩家进行投票\n4. 主持人统计投票结果，并告知所有玩家，投出的角色是谁。\n\n该任务的参与者为主持人和所有存活的玩家，信息可见对象是所有玩家。\n\n##输出##\n请以列表的形式，给出参与者的所有行动。每个行动表示为Python可解析的JSON，格式为\n```\n{"action": {player_name, agent_name}, "observation" or "Dungeon_Master": [{content, memory_tag}, ...]}\n```\n关键词含义如下：\n_ player_name (str): 行动方的 player_name，若行动方为主持人，为空，否则为玩家的 player_name；\n_ agent_name (str): 行动方的 agent_name，若为主持人，则 agent_name 为 "主持人"，否则为玩家的 agent_name。\n_ content (str): 行动方的具体行为，若为主持人，content 为告知信息；否则，content 为玩家的具体行动。\n_ memory_tag (List[str]): 无论行动方是主持人还是玩家，memory_tag 固定为**所有**信息可见对象的agent_name, 如果信息可见对象为所有玩家，固定为 ["all"]\n\n##example##\n如果是玩家发言，则用 {"action": {"agent_name": "agent_name_c", "player_name":"player_name_d"}, "observation": [{"content": "str", "memory_tag":["agent_name_a","agent_name_b"]}]} 格式表示。content是玩家发出的信息；memory_tag是这条信息可见的对象，需要填写agent名。不要填写 agent_description\n\n如果agent_name是主持人，则无需输入player_name， 且observation变为 Dungeon_Master。即{"action": {"agent_name": "主持人", "player_name":""}, "Dungeon_Master": [{"content": "str", memory_tag:["agent_name_a","agent_name_b"]}]}\n\n##注意事项##\n1. 所有玩家的座位、身份、agent_name、存活状态等信息在开头部分已给出。\n2. "observation" or "Dungeon_Master"如何选择？若 agent_name 为"主持人"，则为"Dungeon_Master"，否则为 "observation"。\n3. 输出列表的最后一个元素一定是{"action": "taskend"}。\n4. 整个list是一个jsonstr，请直接输出jsonstr，不用输出markdown格式\n\n##结果##\n',
#    'name': '票选凶手'}},
#  {'id': '剧本杀/谁是卧底/智能交互/票选卧底_1',
#   'type': 'opsgptkg_task',
#   'attributes': {'executetype': '',
#    'description': '##以上为本局游戏历史记录##\n##角色##\n你是一个统计票数大师，你正在参与“谁是卧底”这个游戏，你的角色是[主持人]。你熟悉“谁是卧底”游戏的完整流程，你需要完成[任务]，保证游戏的顺利进行。 现在是投票阶段。\n\n##任务##\n以结构化的语句来模拟进行 谁是卧底的投票环节， 也仅仅只模拟投票环节，投票环节结束后就本阶段就停止了，由后续的阶段继续进行游戏。 在这一个环节里，由主持人先告知大家投票规则，然后组织每位存活玩家按照座位顺序发言投票, 所有人投票后，本阶段结束。 \n##详细步骤##\n你的任务如下:\nstep1. 向所有玩家通知现在进入了票选环节，在这个环节，每个人都一定要投票指定某一个玩家为卧底\nstep2. 主持人确定投票顺序并告知所有玩家。 投票顺序基于如下规则: 1: 存活的玩家按照座位顺序由小到大进行投票（一个例子：假设总共有5个玩家，如果3号位置处玩家死亡，则投票顺序为：1_>2_>4_>5）2: 按座位号依次投票，每个玩家只能对一个玩家进行投票。每个玩家只能投一次票。3：票数最多的玩家会立即死亡\n\nstep3. 存活的的玩家按照顺序进行投票\nstep4. 所有存活玩家发言完毕,主持人宣布投票环节结束\n该任务的参与者为主持人和所有存活的玩家，信息可见对象是所有玩家。\n##注意##\n\n1.之前的游戏轮数可能已经投票选中了某位/某些玩家，被票选中的玩家会立即死亡，不再视为存活玩家      \n2.你要让所有存活玩家都参与投票，不能遗漏任何存活玩家。在本轮每一位玩家只投票一个人\n3.该任务的参与者为主持人和所有存活的玩家，信息可见对象为所有玩家。\n4.不仅要模拟主持人的发言，还需要模拟玩家的发言\n5.不允许玩家自己投自己，如果出现了这种情况，主持人会提醒玩家重新投票。\n\n\n\n##输出##\n请以列表的形式，给出参与者的所有行动。每个行动表示为JSON，格式为\n["thought": str, {"action": {"player_name":str, "agent_name":str}, "observation" or "Dungeon_Master": [{"memory_tag":str,"content":str}]}, ...]\n关键词含义如下：\n_ thought (str): 主持人执行行动的一些思考,包括分析玩家的存活状态，对历史对话信息的理解，对当前任务情况的判断。 \n_ player_name (str): ***的 player_name，若行动方为主持人，为空，否则为玩家的 player_name；\n_ agent_name (str): ***的 agent_name，若为主持人，则 agent_name 为 "主持人"，否则为玩家的 agent_name。\n_ content (str): 行动方的具体行为，若为主持人，content 为告知信息；否则，content 为玩家的具体行动。\n_ memory_tag (List[str]): 无论行动方是主持人还是玩家，memory_tag 固定为**所有**信息可见对象的agent_name, 如果信息可见对象为所有玩家，固定为 ["all"]\n##example##\n如果是玩家发言，则用 {"thought": "str", "action": {"agent_name": "agent_name_c", "player_name":"player_name_d"}, "observation": [{ "memory_tag":["agent_name_a","agent_name_b"],"content": "str"}]} 格式表示。content是玩家发出的信息；memory_tag是这条信息可见的对象，需要填写agent名。不要填写 agent_description\n如果agent_name是主持人，则无需输入player_name， 且observation变为 Dungeon_Master。即{"thought": "str", "action": {"agent_name": "主持人", "player_name":""}, "Dungeon_Master": [{ "memory_tag":["agent_name_a","agent_name_b"], "content": "str",}]}\n##注意事项##\n1. 所有玩家的座位、身份、agent_name、存活状态等信息在开头部分已给出。\n2. "observation" or "Dungeon_Master"如何选择？若 agent_name 为"主持人"，则为"Dungeon_Master"，否则为 "observation"。\n3. 输出列表的最后一个元素一定是{"action": "taskend"}。\n4. 整个list是一个jsonstr，请输出jsonstr，不用输出markdown格式\n5. 结合已有的步骤，每次只输出下一个步骤，即一个 {"thought":  str, "action": {"player_name":str, "agent_name":str}, "observation" or "Dungeon_Master": [{"memory_tag":str,"content":str}]}\n6. 如果是人类玩家发言， 一定要选择类似 人类agent 这样的agent_name',
#    'name': '票选卧底',
#    'accesscriteria': '',
#    'extra': '{"pattern": "react", "endcheck": "True", "memory_tag":"all","dodisplay":"True"}'}},
#  {'id': '剧本杀/谁是卧底/智能交互/关键信息_4',
#   'type': 'opsgptkg_task',
#   'attributes': {'extra': '{"ignorememory":"True","dodisplay":"True"}',
#    'executetype': '',
#    'description': '关键信息_4',
#    'name': '关键信息_4',
#    'accesscriteria': ''}},
#  {'id': '剧本杀/谁是卧底/智能交互/统计票数',
#   'type': 'opsgptkg_task',
#   'attributes': {'executetype': '',
#    'description': '##以上为本局游戏历史记录##\n##角色##\n你是一个统计票数大师，你非常擅长计数以及统计信息。你正在参与“谁是卧底”这个游戏，你的角色是[主持人]。你熟悉“谁是卧底”游戏的完整流程，你需要完成[任务]，保证游戏的顺利进行。 现在是票数统计阶段\n\n##任务##\n以结构化的语句来模拟进行 谁是卧底的票数统计阶段， 也仅仅只票数统计阶段环节，票数统计阶段结束后就本阶段就停止了，由后续的阶段继续进行游戏。 在这一个环节里，由主持人根据上一轮存活的玩家投票结果统计票数。 \n##详细步骤##\n你的任务如下:\nstep1. 主持人感知上一轮投票环节每位玩家的发言, 统计投票结果，格式为[{"player_name":票数}]. \nstep2  然后，主持人宣布死亡的玩家，以最大票数为本轮被投票的目标，如果票数相同，则取座位号高的角色死亡。并告知所有玩家本轮被投票玩家的player_name。（格式为【重要通知】本轮死亡的玩家为XXX）同时向所有玩家宣布，被投票中的角色会视为立即死亡（即不再视为存活角色）\nstep3. 在宣布死亡玩家后，本阶段流程结束，由后续阶段继续推进游戏\n该任务的参与者为主持人和所有存活的玩家，信息可见对象是所有玩家。\n##注意##\n1.如果有2个或者两个以上的被玩家被投的票数相同，则取座位号高的玩家死亡。并告知大家原因：票数相同，取座位号高的玩家死亡\n2.在统计票数时，首先确认存活玩家的数量，再先仔细回忆，谁被投了。 最后统计每位玩家被投的次数。 由于每位玩家只有一票，所以被投次数的总和等于存活玩家的数量 \n3.通知完死亡玩家是谁后，本阶段才结束，由后续阶段继续推进游戏。输出 {"action": "taskend"}即可\n4.主持人只有当通知本轮死亡的玩家时，才使用【重要通知】的前缀，其他情况下不要使用【重要通知】前缀\n5.只统计上一轮投票环节的情况\n##example##\n{"thought": "在上一轮中, 存活玩家有 小北,李光,赵鹤,张良 四个人。 其中 小北投了李光, 赵鹤投了小北, 张良投了李光, 李光投了张良。总结被投票数为： 李光:2票; 小北:1票,张良:1票. Check一下，一共有四个人投票了，被投的票是2（李光）+1（小北）+1（张良）=4，总结被投票数没有问题。 因此李光的票最多", "action": {"agent_name": "主持人", "player_name":""}, "Dungeon_Master": [{ "memory_tag":["all"], "content": "李光:2票; 小北:1票,张良:1票 .因此李光的票最多.【重要通知】本轮死亡玩家是李光",}]}\n\n##example##\n{"thought": "在上一轮中, 存活玩家有 小北,人类玩家,赵鹤,张良 四个人。 其中 小北投了人类玩家, 赵鹤投了小北, 张良投了小北, 人类玩家投了张良。总结被投票数为：小北:2票,人类玩家:1票,张良:0票 .Check一下，一共有四个人投票了，被投的票是2（小北）+1（人类玩家）+张良（0）=3，总结被投票数有问题。 更正总结被投票数为：小北:2票,人类玩家:1票,张良:1票。因此小北的票最多", "action": {"agent_name": "主持人", "player_name":""}, "Dungeon_Master": [{ "memory_tag":["all"], "content": "小北:2票,人类玩家:1票,张良:1票 .因此小北的票最多.【重要通知】本轮死亡玩家是小北",}]}\n\n\n##输出##\n请以列表的形式，给出参与者的所有行动。每个行动表示为JSON，格式为\n["thought": str, {"action": {"player_name":str, "agent_name":str}, "observation" or "Dungeon_Master": [{"memory_tag":str,"content":str}]}, ...]\n关键词含义如下：\n_ thought (str): 主持人执行行动的一些思考,包括分析玩家的存活状态，对历史对话信息的理解，对当前任务情况的判断。 \n_ player_name (str): ***的 player_name，若行动方为主持人，为空，否则为玩家的 player_name；\n_ agent_name (str): ***的 agent_name，若为主持人，则 agent_name 为 "主持人"，否则为玩家的 agent_name。\n_ content (str): 行动方的具体行为，若为主持人，content 为告知信息；否则，content 为玩家的具体行动。\n_ memory_tag (List[str]): 无论行动方是主持人还是玩家，memory_tag 固定为**所有**信息可见对象的agent_name, 如果信息可见对象为所有玩家，固定为 ["all"]\n##example##\n如果是玩家发言，则用 {"thought": "str", "action": {"agent_name": "agent_name_c", "player_name":"player_name_d"}, "observation": [{ "memory_tag":["agent_name_a","agent_name_b"],"content": "str"}]} 格式表示。content是玩家发出的信息；memory_tag是这条信息可见的对象，需要填写agent名。不要填写 agent_description\n如果agent_name是主持人，则无需输入player_name， 且observation变为 Dungeon_Master。即{"thought": "str", "action": {"agent_name": "主持人", "player_name":""}, "Dungeon_Master": [{ "memory_tag":["agent_name_a","agent_name_b"], "content": "str",}]}\n##注意事项##\n1. 所有玩家的座位、身份、agent_name、存活状态等信息在开头部分已给出。\n2. "observation" or "Dungeon_Master"如何选择？若 agent_name 为"主持人"，则为"Dungeon_Master"，否则为 "observation"。\n3. 输出列表的最后一个元素一定是{"action": "taskend"}。\n4. 整个list是一个jsonstr，请输出jsonstr，不用输出markdown格式\n5. 结合已有的步骤，每次只输出下一个步骤，即一个 {"thought":  str, "action": {"player_name":str, "agent_name":str}, "observation" or "Dungeon_Master": [{"memory_tag":str,"content":str}]}\n6. 如果是人类玩家发言， 一定要选择类似 人类agent 这样的agent_name',
#    'name': '统计票数',
#    'accesscriteria': '',
#    'extra': '{"pattern": "react", "endcheck": "True", "memory_tag":"all","model_name":"gpt_4","dodisplay":"True"}'}},
#  {'id': '剧本杀/谁是卧底/智能交互/关键信息_3',
#   'type': 'opsgptkg_task',
#   'attributes': {'accesscriteria': '',
#    'extra': '{"ignorememory":"True","dodisplay":"True"}',
#    'executetype': '',
#    'description': '关键信息',
#    'name': '关键信息'}},
#  {'id': '剧本杀/谁是卧底/智能交互/判断游戏是否结束',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '判断游戏是否结束',
#    'name': '判断游戏是否结束',
#    'accesscriteria': '',
#    'extra': '{"memory_tag": "None","dodisplay":"True"}',
#    'executetype': ''}},
#  {'id': '剧本杀/谁是卧底/智能交互/事实_1',
#   'type': 'opsgptkg_phenomenon',
#   'attributes': {'description': '是', 'name': '是', 'extra': ''}},
#  {'id': '剧本杀/谁是卧底/智能交互/事实_2',
#   'type': 'opsgptkg_phenomenon',
#   'attributes': {'description': '否', 'name': '否', 'extra': ''}},
#  {'id': '剧本杀/谁是卧底/智能交互/给出每个人的单词以及最终胜利者',
#   'type': 'opsgptkg_task',
#   'attributes': {'extra': '{"dodisplay":"True"}',
#    'executetype': '',
#    'description': '给出每个人的单词以及最终胜利者',
#    'name': '给出每个人的单词以及最终胜利者',
#    'accesscriteria': ''}},
#  {'id': '剧本杀/狼人杀/智能交互/判断游戏是否结束',
#   'type': 'opsgptkg_task',
#   'attributes': {'description': '判断游戏是否结束 ',
#    'name': '判断游戏是否结束 ',
#    'accesscriteria': '',
#    'extra': '{"memory_tag": "None"}',
#    'executetype': ''}},
#  {'id': '剧本杀/狼人杀/智能交互/事实_2',
#   'type': 'opsgptkg_phenomenon',
#   'attributes': {'extra': '', 'description': '否', 'name': '否'}},
#  {'id': '剧本杀/狼人杀/智能交互/事实_1',
#   'type': 'opsgptkg_phenomenon',
#   'attributes': {'description': '是', 'name': '是', 'extra': ''}},
#  {'id': '剧本杀/l狼人杀/智能交互/宣布游戏胜利者',
#   'type': 'opsgptkg_task',
#   'attributes': {'extra': '',
#    'executetype': '',
#    'description': '判断游戏是否结束',
#    'name': '判断游戏是否结束',
#    'accesscriteria': ''}},
#  {'id': '剧本杀',
#   'type': 'opsgptkg_intent',
#   'attributes': {'description': '文本游戏相关（如狼人杀等）', 'name': '剧本杀', 'extra': ''}}]

# edges = [('剧本杀', '剧本杀/谁是卧底'),
#  ('剧本杀', '剧本杀/狼人杀'),
#  ('剧本杀/谁是卧底', '剧本杀/谁是卧底/智能交互'),
#  ('剧本杀/狼人杀', '剧本杀/狼人杀/智能交互'),
#  ('剧本杀/谁是卧底/智能交互', '剧本杀/谁是卧底/智能交互/分配座位'),
#  ('剧本杀/狼人杀/智能交互', '剧本杀/狼人杀/智能交互/位置选择'),
#  ('剧本杀/谁是卧底/智能交互/分配座位', '剧本杀/谁是卧底/智能交互/角色分配和单词分配'),
#  ('剧本杀/狼人杀/智能交互/位置选择', '剧本杀/狼人杀/智能交互/角色选择'),
#  ('剧本杀/谁是卧底/智能交互/角色分配和单词分配', '剧本杀/谁是卧底/智能交互/通知身份'),
#  ('剧本杀/狼人杀/智能交互/角色选择', '剧本杀/狼人杀/智能交互/向玩家通知消息'),
#  ('剧本杀/谁是卧底/智能交互/通知身份', '剧本杀/谁是卧底/智能交互/关键信息_1'),
#  ('剧本杀/狼人杀/智能交互/向玩家通知消息', '剧本杀/狼人杀/智能交互/狼人时刻'),
#  ('剧本杀/谁是卧底/智能交互/关键信息_1', '剧本杀/谁是卧底/智能交互/开始新一轮的讨论'),
#  ('剧本杀/狼人杀/智能交互/狼人时刻', '剧本杀/狼人杀/智能交互/天亮讨论'),
#  ('剧本杀/谁是卧底/智能交互/开始新一轮的讨论', '剧本杀/谁是卧底/智能交互/关键信息_2'),
#  ('剧本杀/狼人杀/智能交互/天亮讨论', '剧本杀/狼人杀/智能交互/票选凶手'),
#  ('剧本杀/谁是卧底/智能交互/关键信息_2', '剧本杀/谁是卧底/智能交互/票选卧底_1'),
#  ('剧本杀/谁是卧底/智能交互/票选卧底_1', '剧本杀/谁是卧底/智能交互/关键信息_4'),
#  ('剧本杀/谁是卧底/智能交互/关键信息_4', '剧本杀/谁是卧底/智能交互/统计票数'),
#  ('剧本杀/谁是卧底/智能交互/统计票数', '剧本杀/谁是卧底/智能交互/关键信息_3'),
#  ('剧本杀/谁是卧底/智能交互/关键信息_3', '剧本杀/谁是卧底/智能交互/判断游戏是否结束'),
#  ('剧本杀/谁是卧底/智能交互/判断游戏是否结束', '剧本杀/谁是卧底/智能交互/事实_1'),
#  ('剧本杀/谁是卧底/智能交互/判断游戏是否结束', '剧本杀/谁是卧底/智能交互/事实_2'),
#  ('剧本杀/谁是卧底/智能交互/事实_1', '剧本杀/谁是卧底/智能交互/给出每个人的单词以及最终胜利者'),
#  ('剧本杀/谁是卧底/智能交互/事实_2', '剧本杀/谁是卧底/智能交互/开始新一轮的讨论'),
#  ('剧本杀/狼人杀/智能交互/票选凶手', '剧本杀/狼人杀/智能交互/判断游戏是否结束'),
#  ('剧本杀/狼人杀/智能交互/判断游戏是否结束', '剧本杀/狼人杀/智能交互/事实_2'),
#  ('剧本杀/狼人杀/智能交互/判断游戏是否结束', '剧本杀/狼人杀/智能交互/事实_1'),
#  ('剧本杀/狼人杀/智能交互/事实_2', '剧本杀/狼人杀/智能交互/狼人时刻'),
#  ('剧本杀/狼人杀/智能交互/事实_1', '剧本杀/l狼人杀/智能交互/宣布游戏胜利者'),
#  ('ekg_team_default', '剧本杀')
# ]



tools = [
    "谁是卧底-座位分配", "谁是卧底-角色分配", "谁是卧底-结果输出", "谁是卧底-胜利条件判断",
    "谁是卧底-张伟", "谁是卧底-李静", "谁是卧底-王鹏",
]

# tools = [
#     "狼人杀-角色分配工具", "狼人杀-座位分配", "狼人杀-胜利条件判断", "狼人杀-结果输出",
#     '狼人杀-agent_朱丽', '狼人杀-agent_周杰', '狼人杀-agent_沈强', '狼人杀-agent_韩刚', 
#     '狼人杀-agent_梁军', '狼人杀-agent_周欣怡', '狼人杀-agent_贺子轩'
# ]

AGENT_CONFIGS = {
    "codefuse_function_caller": {
        "config_name": "codefuse_function_caller",
        "agent_type": "FunctioncallAgent",
        "agent_name": "codefuse_function_caller",
        "llm_config_name": "qwen_chat",
        "tools": tools,
    }
}
os.environ["AGENT_CONFIGS"] = json.dumps(AGENT_CONFIGS)

project_config = get_ekg_project_config_from_env()
ekg = EKG(project_config=project_config, initialize_space=False)


# # 添加节点
# for node in nodes:
#     ekg.add_node(node)

# # 添加边
# for start_id, end_id in edges:
#     ekg.add_edge(start_id, end_id)

response = ekg.run("我要玩谁是卧底！",rootid="ekg_team_default")
for i in response:
    pass
